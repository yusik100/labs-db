# Звіт з нормалізації бази даних (Lab 5)

## 1. Аналіз функціональних залежностей (FD)

Для підтвердження коректності структури бази даних було визначено функціональні залежності для основних сутностей.
Позначення: $X \rightarrow Y$ (X однозначно визначає Y).

### **1. Таблиця `User`**

- **PK:** `user_id`
- **FD:** `user_id` $\rightarrow$ `name`, `email`, `password_hash`, `registration_date`
- _Примітка:_ Усі атрибути залежать виключно від ідентифікатора користувача.

### **2. Таблиця `Artist`**

- **PK:** `artist_id`
- **FD:** `artist_id` $\rightarrow$ `stage_name`, `country`, `genre`

### **3. Таблиця `Album`**

- **PK:** `album_id`
- **FD:** `album_id` $\rightarrow$ `title`, `release_year`

### **4. Таблиця `Track`**

- **PK:** `track_id`
- **FD:** `track_id` $\rightarrow$ `title`, `duration_seconds`, `release_date`, `album_id`
- _Примітка:_ `album_id` визначає належність треку до альбому.

### **5. Таблиця `SubscriptionType`**

- **PK:** `type_id`
- **FD:** `type_id` $\rightarrow$ `name`, `price`

### **6. Таблиця `Subscription`**

- **PK:** `subscription_id`
- **FD:** `subscription_id` $\rightarrow$ `user_id`, `type_id`, `start_date`, `end_date`
- _Примітка:_ Ціна підписки залежить від `type_id` через таблицю `SubscriptionType`, що відповідає вимогам 3НФ.

### **7. Таблиця `Playlist`**

- **PK:** `playlist_id`
- **FD:** `playlist_id` $\rightarrow$ `title`, `created_at`, `user_id`

### **8. Таблиця `PlaylistTrack`** (зв’язок M:N)

- **PK:** (`playlist_id`, `track_id`)
- **FD:** Тривіальна залежність. Весь рядок однозначно визначається складеним ключем. Неключових атрибутів немає.

### **9. Таблиця `TrackArtist`** (зв’язок M:N)

- **PK:** (`track_id`, `artist_id`)
- **FD:** Тривіальна залежність. Таблиця забезпечує зв’язок «багато-до-багатьох» між треками та артистами (для фітів та колаборацій). Неключових атрибутів немає.

### **10. Таблиця `AlbumArtist`** (зв’язок M:N)

- **PK:** (`album_id`, `artist_id`)
- **FD:** Тривіальна залежність. Таблиця забезпечує зв’язок «багато-до-багатьох» між альбомами та артистами (для спільних проєктів). Неключових атрибутів немає.

---

## 2\. Перевірка нормальних форм

### Перша нормальна форма (1NF)

**Вимога:** Атомарність атрибутів, відсутність повторюваних груп

- **Перевірка:** У схемі відсутні списки значень (наприклад, у таблиці `Artist` жанри не записані як "Rock, Pop, Jazz" в одній клітинці). У таблиці `Track` немає стовпців `artist1_id`, `artist2_id`. Всі зв'язки винесені в окремі таблиці (`TrackArtist`, `AlbumArtist`).
- **Статус:** Схема відповідає 1NF.

### Друга нормальна форма (2NF)

**Вимога:** Відсутність часткових залежностей (неключові атрибути залежать від усього складеного ключа)

- **Перевірка:**
  - Більшість таблиць мають простий ключ (`SERIAL id`).
  - Таблиці зі складеними ключами (`PlaylistTrack`, `TrackArtist`, `AlbumArtist`) містять лише зовнішні ключі і не мають описових атрибутів (наприклад, date_added), які могли б залежати лише від однієї частини ключа.
- **Статус:** Схема відповідає 2NF.

### Третя нормальна форма (3NF)

**Вимога:** Відсутність транзитивних залежностей (неключовий атрибут залежить від іншого неключового атрибута)

- **Перевірка:**

  - У таблиці `Track` ми зберігаємо `album_id`, але не зберігаємо `album_year`. Рік залежить від альбому, а не від треку. Якби ми додали рік у трек, це було б порушенням (`TrackID` $\rightarrow$ `AlbumID` $\rightarrow$ `Year`).

  - У таблиці `Subscription` ми зберігаємо `type_id`, але не зберігаємо `price`. Ціна залежить від типу підписки.

- **Статус:** Схема відповідає 3NF.

---

## **3. Аналіз потенційних помилок, які були уникнені**

При проєктуванні схеми було враховано вимоги нормалізації. Нижче наведено приклади того, як могла виглядати схема з порушеннями, і як ці проблеми усунено в поточній версії проєкту.

---

### **3.1. Уникнення порушень 1NF (неатомарні значення)**

**Потенційна помилка:**
Спроба зберігати список треків прямо в таблиці альбому у вигляді рядка через кому.

**Приклад таблиці, що НЕ відповідає 1NF:**

```sql
CREATE TABLE Bad_Album (
    album_id INT PRIMARY KEY,
    title VARCHAR(100),
    tracks_list TEXT -- Значення, наприклад: "Believer, Thunder, Whatever It Takes"
);
```

**Чому це погано:**

* Атрибут `tracks_list` не є атомарним (містить множинні значення).
* Неможливо ефективно:

  * виконувати пошук конкретного треку,
  * сортувати треки,
  * оновлювати одну назву без перезапису всього поля,
  * будувати коректні зв’язки між сутностями.

**Правильне рішення в схемі:**
Кожен трек має окремий рядок у таблиці `Track` та містить посилання на `Album` через зовнішній ключ `album_id`. Це забезпечує повну відповідність 1НФ.

---

### **3.2. Уникнення порушень 2NF (часткові залежності у складених ключах)**

Це стосується таблиць із **складеним первинним ключем**, зокрема `PlaylistTrack` (`playlist_id`, `track_id`).

**Потенційна помилка:**
Додавання атрибуту, який залежить лише від однієї частини ключа.

**Приклад таблиці, що НЕ відповідає 2NF:**

```sql
CREATE TABLE Bad_PlaylistTrack (
    playlist_id INT,
    track_id INT,
    playlist_owner_id INT, -- Залежить ТІЛЬКИ від playlist_id
    PRIMARY KEY (playlist_id, track_id)
);
```

**Аналіз порушення:**

* **Первинний ключ:** (`playlist_id`, `track_id`)
* **Функціональна залежність:**
  `playlist_id → playlist_owner_id`

**Проблема:**
`playlist_owner_id` не залежить від повного ключа.
Це часткова залежність → порушення 2НФ.

**Правильне рішення в схемі:**
Атрибут власника (`user_id`) зберігається **лише в таблиці `Playlist`**.
`PlaylistTrack` містить тільки ключі (`playlist_id`, `track_id`) без додаткових атрибутів.

---

### **3.3. Уникнення порушень 3NF (транзитивні залежності)**

**Потенційна помилка:**
Зберігання атрибутів альбому прямо в таблиці треку.

**Приклад таблиці, що НЕ відповідає 3NF:**

```sql
CREATE TABLE Bad_Track (
    track_id SERIAL PRIMARY KEY,
    title VARCHAR(150),
    album_id INT,
    album_release_year INT -- Залежить від album_id, а не track_id
);
```

**Аналіз порушення:**

Функціональні залежності:

* `track_id → album_id`
* `album_id → album_release_year`

Отже:

* `track_id → album_release_year` (транзитивна залежність)

**Проблема (аномалія оновлення):**

Якщо змінити рік випуску альбому, доведеться оновлювати його в кожному треку цього альбому. Це призводить до дублювання й ризику неузгодженості даних.

**Правильне рішення в схемі:**
`release_year` зберігається **виключно в таблиці `Album`**.
Таблиця `Track` містить лише посилання `album_id`, що повністю відповідає 3НФ.

---


## **4. Виявлення та усунення уявної надлишковості (Optimization)**

Під час аналізу вимог до аналітичних запитів (Lab 4) могло виникнути бажання створити окрему таблицю для кешування статистики плейлістів. Однак це призвело б до надлишковості даних і потенційних аномалій.

---

### **4.1. Гіпотетична проблемна таблиця: `PlaylistStats`**

```sql
CREATE TABLE PlaylistStats (
    playlist_id INTEGER PRIMARY KEY,
    total_tracks INTEGER,       -- Можна обчислити як COUNT(*)
    total_duration_sec INTEGER  -- Можна обчислити як SUM(duration)
);
```

---

### **4.2. Виявлені аномалії**

#### **1. Аномалія оновлення**

При додаванні або видаленні треку у `PlaylistTrack` необхідно забезпечити оновлення відповідного запису в `PlaylistStats`.

У випадку збою або помилки можливі розсинхронізації, наприклад:

* у таблиці зазначено *5 треків*,
* а реальних записів у `PlaylistTrack` — *4*.

Це створює ризик неконсистентності даних.

#### **2. Надлишковість**

Таблиця дублює інформацію, яку легко отримати з наявних даних:

* `total_tracks` = `COUNT(*)` по PlaylistTrack
* `total_duration_sec` = `SUM(duration_seconds)` з Track

Зберігання цих агрегатів займає зайве місце та ускладнює підтримку цілісності.

---

### **4.3. Правильне рішення (Нормалізація)**

Замість фізичного збереження агрегованих значень використовується обчислення статистики "на льоту" шляхом SQL-запитів або у вигляді Views.

**SQL-запит, який повністю замінює таблицю `PlaylistStats`:**

```sql
SELECT 
    P.title,
    COUNT(PT.track_id) AS total_tracks,
    SUM(T.duration_seconds) AS total_duration_sec
FROM Playlist P
JOIN PlaylistTrack PT ON P.playlist_id = PT.playlist_id
JOIN Track T ON PT.track_id = T.track_id
GROUP BY P.playlist_id;
```

Цей підхід гарантує:

* відсутність дублювання даних,
* автоматичну актуальність результатів,
* спрощення структури БД,
* відповідність нормальним формам.

---

### **4.4. Висновок**

Схема бази даних спроєктована оптимально, відповідає **3-й нормальній формі (3NF)** та не містить надлишкових даних.
Додаткова декомпозиція не потрібна — усі залежності структуровано логічно та мінімізовано ризики аномалій оновлення.

